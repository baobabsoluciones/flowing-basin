from flowing_basin.core import Instance
import warnings
import pickle
import lightgbm
import numpy as np


class PowerGroup:

    POWER_FLOW_LINE_COEFS = {
        "dam1": [2.99625925, 0.05524465],
        "dam2": [1.32432353, 0.25964468],
    }

    def __init__(
        self,
        idx: str,
        flows_over_time: np.ndarray,
        instance: Instance,
        paths_power_models: dict[str, str],
        num_scenarios: int,
    ):

        self.num_scenarios = num_scenarios

        self.idx = idx
        self.power_model = self.get_power_model(paths_power_models[self.idx])
        self.relevant_lags = instance.get_relevant_lags_of_dam(self.idx)

        # Power generated (MW) and turbined flow (m3/s)
        self.power = self.get_power(flows_over_time)
        self.turbined_flow = self.get_turbined_flow(self.power)

    def reset(self, flows_over_time: np.ndarray):

        self.power = self.get_power(flows_over_time)
        self.turbined_flow = self.get_turbined_flow(self.power)

    @staticmethod
    def get_power_model(path_power_model: str) -> lightgbm.LGBMClassifier:

        """
        Light Gradient Boosting model that predicts the power generated by the power group
        given the flows that had previously passed though the channel (lags)

        The model can be fed the past flows or lags in multiple ways.
        If the relevant lags are 2, 3, 4, 5, with flow values 5.4, 5.6, 3.4, 2.1, then:
        OpA. list:              model_load.predict([[5.4, 5.6, 3.4, 2.1]])
        OpB. NumPy array:       model_load.predict(np.array([5.4, 5.6, 3.4, 2.1]).reshape(1,-1))
        OpC. Pandas dataframe:  model_load.predict(df[["EX_Q_K_lag2", "EX_Q_K_lag3", "EX_Q_K_lag4", "EX_Q_K_lag5"]])
        """

        # Load model under a warnings catch,
        # to avoid seeing the warnings for using a more recent version of scikit-learn
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            model_load = pickle.load(open(path_power_model, "rb"))

        return model_load

    def get_power(self, past_flows: np.ndarray) -> float | np.ndarray:

        """

        :param past_flows: Array of shape num_scenarios x num_lags with all past flows of the channel (m3/s)
        :return:
         - Power generated in this time step (MW)
         - OR Array of shape num_scenarios with the power generated in every scenario (MW)
        """

        # Take only the relevant columns of the array
        first_lag = self.relevant_lags[0]
        last_lag = self.relevant_lags[-1]
        power = self.power_model.predict(past_flows[:, first_lag - 1: last_lag])
        if self.num_scenarios == 1:
            power = power.item()
        return power

    def get_turbined_flow(self, power: float | np.ndarray) -> float | np.ndarray:

        """

        :param power:
         - Power (MW)
         - OR Array of shape num_scenarios with power valoes (MW)
        :return:
         - Corresponding turbined flow (m3/s)
         - OR Array of shape num_scenarios with the corresponding turbined flows (m3/s)
        """

        line = np.poly1d(self.POWER_FLOW_LINE_COEFS[self.idx])
        turbined_flow = line(power)

        return turbined_flow

    def update(self, past_flows: np.ndarray) -> float | np.ndarray:

        """
        Update the current power generated by the power group, as well as its turbined flow
        :param past_flows: Array of shape num_scenarios x num_lags with all past flows of the channel (m3/s)
        :return:
         - Turbined flow in the power group (m3/s)
         - OR Array of shape num_scenarios containing the turbined flow of every scenario (m3/s)
        """

        self.power = self.get_power(past_flows)
        self.turbined_flow = self.get_turbined_flow(self.power)

        # Bring turbined flow upstream, since it is used to update the volume of the next dam
        return self.turbined_flow
