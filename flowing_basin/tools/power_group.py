from flowing_basin.core import Instance
from collections import deque
import warnings
import pickle
import lightgbm


class PowerGroup:
    def __init__(
        self,
        idx: str,
        flows_over_time: deque,
        instance: Instance,
        paths_power_models: dict[str, str],
    ):

        self.idx = idx
        self.power_model = self.get_power_model(paths_power_models[self.idx])
        self.relevant_lags = instance.get_relevant_lags_of_dam(self.idx)

        self.power = self.get_power(flows_over_time)
        self.turbined_flow = self.get_turbined_flow(flows_over_time)

    @staticmethod
    def get_power_model(path_power_model: str) -> lightgbm.LGBMClassifier:

        """
        Light Gradient Boosting model that predicts the power generated by the power group
        given the flows that had previously passed though the channel (lags)

        The model can be fed the past flows or lags in multiple ways.
        If the relevant lags are 2, 3, 4, 5, with flow values 5.4, 5.6, 3.4, 2.1, then:
        OpA. list:              model_load.predict([[5.4, 5.6, 3.4, 2.1]])
        OpB. NumPy array:       model_load.predict(np.array([5.4, 5.6, 3.4, 2.1]).reshape(1,-1))
        OpC. Pandas dataframe:  model_load.predict(df[["EX_Q_K_lag2", "EX_Q_K_lag3", "EX_Q_K_lag4", "EX_Q_K_lag5"]])
        """

        # Load model under a warnings catch,
        # to avoid seeing the warnings for using a more recent version of scikit-learn
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            model_load = pickle.load(open(path_power_model, "rb"))

        return model_load

    def get_power(self, flows_over_time: deque) -> float:

        """

        :param flows_over_time: Flows assigned in the previous time steps to the channel
        :return: Power generated in this time step
        """

        lags = [flows_over_time[lag - 1] for lag in self.relevant_lags]
        return float(self.power_model.predict([lags]))

    def get_turbined_flow(self, flows_over_time: deque) -> float:

        """

        :param flows_over_time: Flows assigned in the previous time steps to the preceding channel
        :return: Turbined flow in this time step
        """

        # TODO: implement this function

        return 0

    def update(self, flows_over_time: deque) -> float:

        """
        Update the current power generated by the power group, as well as its turbined flow
        :param flows_over_time:
        :return: Turbined flow in the power group
        """

        self.power = self.get_power(flows_over_time)
        self.turbined_flow = self.get_turbined_flow(flows_over_time)

        # Bring turbined flow upstream, since it is used to update the volume of the next dam
        return self.turbined_flow
