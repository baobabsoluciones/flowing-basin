from flowing_basin.core import Instance
from .dam import Dam


class RiverBasin:
    def __init__(self, instance: Instance, paths_power_models: dict[str, str]):

        # Dams inside the flowing basin
        self.dams = []
        dam_ids = instance.get_ids_of_dams()
        for dam_id in dam_ids:
            dam = Dam(
                idx=dam_id,
                instance=instance,
                paths_power_models=paths_power_models,
            )
            self.dams.append(dam)

        # Identifier of the time step (increases with each update)
        self.time = 0

        # Save instance to get incoming flows in the update method
        self.instance = instance

    def update(self, flows: dict[str, float]) -> None:

        """

        :param flows: Dictionary of flows that should go through each channel, indexed by dam
        """

        # The first dam has no preceding dam
        turbined_flow_of_preceding_dam = 0

        # Update dams
        for dam in self.dams:
            turbined_flow = dam.update(
                flows=flows,
                incoming_flow=self.instance.get_incoming_flow(self.time),
                turbined_flow_of_preceding_dam=turbined_flow_of_preceding_dam,
            )
            turbined_flow_of_preceding_dam = turbined_flow

        # Increase time step identifier to get the next incoming flow
        self.time = self.time + 1

    def get_state(self):

        """
        Returns the state of the river basin
        (volume of every dam, flow through each channel, power generated by every power group, etc.)
        :return:
        """

        volumes = []
        unregulated_flows = []
        incoming_flow = self.instance.get_incoming_flow(self.time)
        price = self.instance.get_price(self.time)
        lags = []
        powers = []

        for dam in self.dams:
            volumes.append(dam.volume)
            unregulated_flows.append(dam.unregulated_flow)
            lags.append(dam.channel.flows_over_time)
            powers.append(dam.channel.power_group.power)

        return volumes, unregulated_flows, incoming_flow, price, lags, powers
